<!DOCTYPE html>
<html>

<head>
    <title>Journey Through Europe</title>
    <link href="https://fonts.googleapis.com/css?family=VT323" rel="stylesheet">
    <style type="text/css">

    * {
        box-sizing: border-box;
    }

    body, button {
        font-family: "VT323", monospace;
        font-size: 1.2em;
    }

    button {
        padding: 6px 12px;
        font-size: 30px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
    }

    button:hover {
        background: #e6e6e6;
        cursor: pointer;
    }

    #left-panel, #right-panel {
    }

    #left-panel {
        float: left;
        width: 70%;
    }

    #right-panel {
        float: right;
        width: 30%;
    }

    #player-list, #card-list {
        display: table;
        width: 100%;
        padding: 0;
        margin: 0;
    }

    #player-list {
        color: white;
    }

    #player-list li, #card-list li {
        text-align: center;
        display: table-cell;
        padding: 20px;
    }

    #card-list li {
        border: 1px solid black;
    }

    #card-list li.visited {
        background: #bbb;
    }

    .player-name {
        font-size: 1.2em;
    }

    .current-player {
        font-weight: bold;
    }

    #right-panel .message {
        margin: 8px;
        border-bottom: 1px solid #555;
    }

    .popup {
        display: none;
        position: fixed;
        width: 400px;
        top: 200px;
        left: 50%;
        margin-left: -200px;
        border: 3px solid black;
        background: #ddd;
        padding: 40px;
        text-align: center;
        z-index: 101;
    }

    #gray-screen {
        display: none;
        position: fixed;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        opacity: 0.5;
        background: gray;
        z-index: 100;
    }

    #action-choice-popup ul {
        padding-left: 0;
    }

    #action-choice-popup li {
        list-style: none;
        margin-bottom: 10px;
    }

    #canvas-wrapper {
        position: relative;
    }

    #roll-dice-button, #dice-points {
        display: none;
        position: absolute;
        top: 3px;
        right: 3px;
    }

    </style>
</head>

<body>
    <script type="text/json" id="cities">
    {{ cities }}
    </script>
    <script type="text/json" id="airports">
    {{ airports }}
    </script>


    <h1>Journey Through Europe</h1>

    <!-- <code id="debug-area"></code> -->

    <div id="left-panel">
        <ol id="player-list"></ol>
        <ol id="actions-list"></ol>

        <div id="canvas-wrapper">
            <button id="roll-dice-button">Roll</button>
            <img id="dice-points" width="50" height="50" />
            <canvas id="game-canvas"></canvas>
        </div>

        <ol id="card-list"></ol>
    </div>

    <div id="gray-screen"></div>
    <div id="action-choice-popup" class="popup">
        Choose action...
        <ul></ul>
    </div>

    <div id="right-panel"></div>

    <script type="text/javascript" src="https://joesingo.github.io/grid/matrix.js"></script>
    <script type="text/javascript" src="https://joesingo.github.io/grid/grid.js"></script>
    <script type="text/javascript" src="/static/jquery-3.1.1.min.js"></script>
    <script type="text/javascript">

    function Map(cities_str, airports_str) {

        var cities = JSON.parse(cities_str);
        var airports = JSON.parse(airports_str);

        /*
         * Throw an exception if the provided ID is invalid;
         */
        var checkCityID = function(city_id) {
            if (city_id < 0 || city_id >= cities.length) {
                throw "Invalid city ID";
            }
        }

        /*
         * Return the name of the city with the given ID. Throw an exception if the
         * city does not exist
         */
        this.getCityName = function(city_id) {
            var i = parseInt(city_id);
            checkCityID(i);
            return cities[i].name;
        }

        /*
         * Return the coordinates in the map image for a given city
         */
        this.getCityCoords = function(city_id) {
            var i = parseInt(city_id);
            checkCityID(i);

            return cities[i].coords;
        }

        /*
         * Return the array of cities
         */
        this.getCities = function() {
            return cities;
        }

        this.getAirports = function() {
            return airports;
        }
    }

    function Game(game_map, canvas) {

        var map = game_map;

        // Store name, city_id pairs so that we can animate player movement
        // when city changes
        var player_locations = {};

        var grid = new Grid(canvas);

        grid.settings.background_colour = "black";
        grid.settings.grid_lines = {};
        grid.settings.axes.enabled = false;
        grid.redraw();

        // Draw background image so that it fills the canvas
        var fullscreen_ratio = grid.getUnitsToPx();
        var map_width = canvas.width * fullscreen_ratio;
        var map_height = canvas.height * fullscreen_ratio;
        var background = grid.addImage(images.map, 0, 0, map_width, map_height);
        grid.translate(-0.5*map_width, 0.5*map_height);

        // A list of the current points on the map that can be clicked
        var click_points = [];

        var hovered_click_point = null;

        // grid object IDs for the player flags
        var player_flag_ids = [];

        var sprites = {
            "player_flags": [],
            "click_points": [],
            "located_cities": {},  // indexed by city id for easy removal
            "labels": {}  // indexed by city id also
        };

        // Calculate sizes of things in grid units based on size in pixels at
        // fullscreen zoom level
        var sizes = {}
        for (var i in ART_SIZES) {
            sizes[i] = ART_SIZES[i] * fullscreen_ratio * canvas.width / images.map.width;
        }

        // Keep track of zooming for hiding/displaying non-airport city labels
        var zoom_factor = 1;

        /*
         * Convert coordinates in px relative to the map image to grid
         * coordinates
         */
        this.getCoords = function(img_x, img_y) {
            return [map_width * img_x / images.map.width,
                    map_height * (1 - img_y) / images.map.height];
        }

        /*
         * Return how many times the zoom level has increased by a factor of
         * ZOOM_THRESHOLD. e.g. if the threshold is 2 then zoom level increases
         * at x2, x4, x8 zoom etc...
         */
        this.getZoomLevel = function() {
            return Math.floor(Math.log(zoom_factor) / Math.log(ZOOM_THRESHOLD));
        }

        /*
         * Set the font size of the city labels
         */
        this.setLabelSizes = function() {
            var zoom_level = this.getZoomLevel();

            for (var city_id in sprites.labels) {
                var obj = grid.getObject(sprites.labels[city_id]);

                // Always show airport labels, and only show others is level is
                // positive
                if ("airport" in obj.data || zoom_level > 0) {
                    obj.style.font_size = LABEL_SIZE;
                }
                else {
                    obj.style.font_size = 0;
                }
            }
            grid.redraw();
        }

        /*
         * Add a text label for each city
         */
        this.addLabels = function() {
            var cities = map.getCities();
            var airports = map.getAirports();

            for (var i=0; i<cities.length; i++) {
                var grid_coords = this.getCoords(cities[i].coords[0], cities[i].coords[1]);
                grid_coords[1] += 1.5 * sizes.city_radius;
                var id = grid.addText(cities[i].name, grid_coords[0], grid_coords[1],
                                      "center", LABEL_STYLE);

                sprites.labels[i] = id;
            }

            // Set a flag in data object for airport city labels
            for (var i=0; i<airports.length; i++) {
                var obj = grid.getObject(sprites.labels[airports[i]]);
                obj.data.airport = true;
            }

            this.setLabelSizes();
        }

        /*
         * Add a player flag to the grid and add the object ID to the
         * sprites.player_flags. Return an array continaing the grid.js object
         * IDs of the shapes created
         */
        this.addPlayerFlag = function(name, colour, city) {

            var img_coords = map.getCityCoords(city);
            var grid_coords = this.getCoords(img_coords[0], img_coords[1]);

            var points = [];
            var x = grid_coords[0] - 0.5*sizes.flagpole_width;
            var y = grid_coords[1];
            points.push([x, y]);
            y += sizes.flagpole_height;
            points.push([x, y]);
            x += sizes.flagpole_width;
            points.push([x, y]);
            x += sizes.flag_size;
            points.push([x, y]);
            y -= sizes.flag_size;
            points.push([x, y]);
            x -= sizes.flag_size;
            points.push([x, y]);
            y = grid_coords[1];
            points.push([x, y]);

            var id = grid.addShape(points, {"colour": colour, "fill": true});
            var id2 = grid.addShape(points, {"colour": "white", "fill": false,
                                             "line_width": 2});
            sprites.player_flags.push([id, id2]);
            return [id, id2];
        }

        /*
         * Add a circle at the coordinates of a city. circle_style is one of
         * LOCATING_CIRCLE or TRAVEL_CIRCLE. Return an array continaing the grid.js object
         * IDs of the shapes created
         */
        this.addCityCircle = function(coords, circle_style, airport) {
            var border_style = {"colour": "white", "fill": true};
            var border_id = grid.addCircle(coords[0], coords[1],
                                           sizes.city_radius,
                                           border_style);

            var style = {"fill": true};

            switch (circle_style) {
                case TRAVEL_CIRCLE:
                    style.colour = (airport ? "red": "black")
                    break

                case LOCATING_CIRCLE:
                    style.colour = "blue";
                    break;
            }

            var inner_id = grid.addCircle(
                coords[0], coords[1],
                sizes.city_radius - sizes.city_border_width,
                style
            );

            return [border_id, inner_id];
        }

        /*
         * Return the step function to animate moving grid.js shapes along the
         * direction vector provided. It is assumed that the animation will be
         * run with the parameter going from 0 to 1
         */
        this.animateShapes = function(object_ids, direction) {
            var initial_coords = [];
            for (var i=0; i<object_ids.length; i++) {
                var obj = grid.getObject(object_ids[i]);
                initial_coords.push([]);

                for (var j=0; j<obj.data.points.length; j++) {
                    initial_coords[i].push(obj.data.points[j]);
                }
            }

            return function(t) {
                for (var i=0; i<object_ids.length; i++) {
                    var obj = grid.getObject(object_ids[i]);

                    for (var j=0; j<obj.data.points.length; j++) {
                        obj.data.points[j] = [
                            initial_coords[i][j][0] + t * direction[0],
                            initial_coords[i][j][1] + t * direction[1]
                        ];
                    }
                }
            };
        }

        /*
         * Update the player list and draw flags on the canvas
         */
        this.drawPlayers = function(status) {

            // Remove all previous flags
            for (var i=0; i<sprites.player_flags.length; i++) {
                grid.removeObject(sprites.player_flags[i][0]);
                grid.removeObject(sprites.player_flags[i][1]);
            }
            sprites.player_flags = [];
            grid.redraw();

            for (var i=0; i<status.players.length; i++) {

                var $name_span = $("<span>", {"class": "player-name"});
                $name_span.text(status.players[i].name);

                if (name == status.current_player) {
                    $name_span.addClass("current-player");
                }

                var text = map.getCityName(status.players[i].current_city) +
                                           " (" + status.players[i].progress +
                                           ")";

                var $item = $("<li>", {"css": {"background": COLOURS[i]}});
                $item.append($name_span, "<br />", text);
                $("#player-list").append($item);

                // See if this player was in a different city previously so that
                // we can animate the movement
                var animating = false;
                if (status.players[i].name in player_locations &&
                    player_locations[status.players[i].name] != status.players[i].current_city)
                {
                    animating = true;

                    // Add a flag at the PREVIOUS city
                    var prev_city = player_locations[status.players[i].name];
                    var ids = this.addPlayerFlag(status.players[i].name,
                                                 COLOURS[i], prev_city);

                    // Calculate the start and target coordinates and
                    // direction vector
                    var s_img_coords = map.getCityCoords(prev_city);
                    var t_img_coords = map.getCityCoords(status.players[i].current_city);
                    var s_coords = this.getCoords(s_img_coords[0], s_img_coords[1]);
                    var t_coords = this.getCoords(t_img_coords[0], t_img_coords[1]);
                    var direction = [t_coords[0] - s_coords[0],
                                     t_coords[1] - s_coords[1]];

                    grid.runAnimation(this.animateShapes(ids, direction), 0, 1,
                                      1 / ANIMATION_TIME);
                }

                if (!animating) {
                    this.addPlayerFlag(status.players[i].name, COLOURS[i],
                                       status.players[i].current_city);
                }
            }

            // Update player_locations
            player_locations = {};
            for (var i=0; i<status.players.length; i++) {
                player_locations[status.players[i].name] = status.players[i].current_city;
            }
        }

        /*
         * Update the player's cards showing which have been visited
         */
        this.drawCards = function(status) {
            for (let i=0; i<status.cards.length; i++) {
                var $li = $("<li>").css("cursor", "pointer")
                                   .append(map.getCityName(status.cards[i].id));

                var g = this;

                // Toggle city location on clicck
                $li.on("click", function() {
                    if ($(this).hasClass("located")) {
                        $(this).removeClass("located");
                        g.hideCityLocation(status.cards[i].id);
                    }
                    else {
                        $(this).addClass("located");
                        g.showCityLocation(status.cards[i].id);
                    }
                });

                if (status.cards[i].visited) {
                    $li.addClass("visited");
                }

                $("#card-list").append($li);
            }
        }

        /*
         * Show the available actions to the user
         */
        this.drawActions = function(status) {
            for (let i=0; i<status.actions.length; i++) {
                var description = "";

                switch (status.actions[i].type) {
                    case ROLL_DICE_ACTION:
                        description = "Roll dice";

                        // Show button, remove previous click handlers, and add
                        // new click handler to perform action
                        $("#roll-dice-button").show().off("click")
                                              .on("click",function() {
                            performAction(status.actions[i].id);
                            $(this).hide();
                        });
                        break;

                    case TRAVEL_ACTION:
                        var city_id = status.actions[i].link.to_city;
                        var city_name = map.getCityName(city_id);
                        var type = status.actions[i].link.type;
                        description = `Travel to ${city_name} via ${type}`;

                        var img_coords = map.getCityCoords(city_id);
                        var coords = this.getCoords(img_coords[0], img_coords[1]);
                        var ids = this.addCityCircle(coords, TRAVEL_CIRCLE, (type == AIR_LINK));
                        sprites.click_points.push(ids)

                        if (!(city_id in click_points)) {
                            click_points[city_id] = {"coords": coords,
                                                     "actions": []};
                        }
                        click_points[city_id].actions.push({
                            "id": status.actions[i].id,
                            "link_type": type
                        });
                        break;

                    case WAIT_AT_PORT_ACTION:
                        description = "Wait at port";
                        break;
                }

                var $link = $(
                    "<a>",
                    {"href": "#",
                     "onclick": `performAction(${status.actions[i].id})`,
                     "text": description}
                );
                var $item = $("<li>");
                $item.append($link);
                // $("#actions-list").append($item);
            }
        }

        /*
         * Return the click point object at (x, y) or null if no such point
         * exists
         */
        this.getClickPoint = function(x, y) {
            for (var i in click_points) {
                var cx = click_points[i].coords[0];
                var cy = click_points[i].coords[1];
                var distance = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));

                if (distance <= sizes.city_radius) {
                    return click_points[i];
                }
            }

            return null;
        }

        this.showCityLocation = function(city_id) {
            var img_coords = map.getCityCoords(city_id);
            var grid_coords = this.getCoords(img_coords[0], img_coords[1]);
            var ids = this.addCityCircle(grid_coords, LOCATING_CIRCLE, false);
            sprites.located_cities[city_id] = ids;
        }

        this.hideCityLocation = function(city_id) {
            var ids = sprites.located_cities[city_id];
            for (var i=0; i<ids.length; i++) {
                grid.removeObject(ids[i]);
            }
            grid.redraw();
            delete sprites.located_cities[city_id];
        }

        /*
         * Clear the game canvas and update the player list, cards, and canvas
         */
        this.updateDisplay = function(status) {

            // Remove any previous player flags
            for (var i=0; i<player_flag_ids.length; i++) {
                grid.removeObject(player_flag_ids[i][0]);
                grid.removeObject(player_flag_ids[i][1]);
            }
            player_flag_ids = [];

            // Update message log
            for (var i=0; i<status["message_log"].length; i++) {
                var msg = status["message_log"][i];

                var $msgs = $("#right-panel .game-message");

                if ($msgs.length == 0 ||
                    msg["timestamp"] > $msgs.last().data("timestamp")) {

                    var $msg_p = $("<p>", {"class": "message game-message"});
                    $msg_p.data("timestamp", msg["timestamp"]);
                    $msg_p.text(msg["message"]);

                    $("#right-panel").append($msg_p);
                }
            }

            $("#actions-list").text("");

            // Remove city circles
            for (var i=0; i<sprites.click_points.length; i++) {
                grid.removeObject(sprites.click_points[i][0]);
                grid.removeObject(sprites.click_points[i][1]);
            }
            sprites.click_points = [];

            click_points = [];
            hovered_click_point = null;

            $("#dice-points").hide();

            if ("actions" in status) {
                this.drawActions(status);

                if (status.dice_points) {
                    $("#dice-points").prop("src", `/static/dice/${status.dice_points}.png`).show();
                }
            }

            $("#player-list").text("");
            this.drawPlayers(status);

            // Show cards
            $("#card-list").text("");
            this.drawCards(status);

            grid.redraw();
        }

        var g = this;
        canvas.addEventListener("mousemove", function(e) {
            var grid_coords = grid.fromCanvasCoords(e.offsetX, e.offsetY);

            var click_point = g.getClickPoint(grid_coords[0], grid_coords[1]);

            if (click_point) {
                hovered_click_point = click_point;
                document.body.style.cursor = "pointer";
            }
            // Unhover if a point was previously hovered but is not now
            else if (hovered_click_point) {
                hovered_click_point = null;
                document.body.style.cursor = "default";
            }
        });

        canvas.addEventListener("click", function(e) {
            if (hovered_click_point) {

                // Perform action straigt away if there is only one for this
                // click point...
                if (hovered_click_point.actions.length == 1) {
                    performAction(hovered_click_point.actions[0].id);
                }
                // ...otherwise show popup so that user can choose
                else {
                    var $list = $("#action-choice-popup ul");
                    $list.text("");

                    for (let i=0; i<hovered_click_point.actions.length; i++) {
                        var type = hovered_click_point.actions[i].link_type;
                        var $button = $("<button>", {"text": `Travel by ${type}`})
                        let id = hovered_click_point.actions[i].id;

                        $button.on("click", function() {
                            performAction(id);
                            hidePopup("action-choice-popup");
                        });

                        $list.append($("<li>").append($button));
                    }

                    showPopup("action-choice-popup");
                }

                // Reset cursor once clicked
                document.body.style.cursor = "default";
            }
        });

        /*
         * Add callback function to grid zooming to redraw labels when zoom level
         * changes
         */
        grid.settings.zoom.callback = function(zoom, x, y) {
            var current_level = g.getZoomLevel();
            zoom_factor *= 1 + zoom;
            var new_level = g.getZoomLevel();

            if (new_level != current_level) {
                g.setLabelSizes();
            }
        }

        this.addLabels();
    }

    /*
     * Show a semi-opaque rectangle to gray out the screen and show a fixed
     * position popup
     */
    function showPopup(id) {
        $("#gray-screen").show();
        $("#" + id).show();
    }
    function hidePopup(id) {
        $("#gray-screen").hide();
        $("#" + id).hide();
    }

    /*
     * Send an AJAX request to perform the specified action. Immediately update
     * status if the request is successful
     */
    function performAction(action_id) {
        $("#action-list").text("Loading...");
        $.ajax(ACTION_URL, {
            "method": "POST",
            "data": {
                "action_id": action_id
            },
            "error": function(request, status, error) {
                throw "Unexpected error performing action";
            },
            "success": function(response, status, request) {
                getStatus();
            }
        });
    }

    /*
     * Send an AJAX request to be updated on the current status of the game
     */
    function getStatus() {
        $.ajax(STATUS_URL + latest_timestamp + "/", {
            "method": "GET",
            "error": function(request, status, error) {
                throw "Unexpected error retrieving status";
            },
            "success": function(response, status, request) {
                // $("#debug-area").text(response);

                // Only update if the response was 200 (i.e. something new
                // has happened)
                if (request.status == 200) {
                    var game_status = JSON.parse(response);
                    latest_timestamp = game_status.timestamp;

                    game.updateDisplay(game_status);
                }
            }
        });
    }

    const UPDATE_INTERVAL = 1000;

    const ROLL_DICE_ACTION = "roll_dice";
    const TRAVEL_ACTION = "travel";
    const WAIT_AT_PORT_ACTION = "wait_at_port";

    const LAND_LINK = "land";
    const SEA_LINK = "sea";
    const AIR_LINK = "air";

    // The length of the player movement animation in seconds
    const ANIMATION_TIME = 0.7;

    // The different styles of circles at cities
    const LOCATING_CIRCLE = "locating";
    const TRAVEL_CIRCLE = "travlel";

    const COLOURS = ["#AA3939", "#226666", "#AA8439"];

    const ZOOM_THRESHOLD = 2.2;

    var STATUS_URL = window.location.pathname + "status/";
    var ACTION_URL = window.location.pathname + "action/";

    // Sizes of art assets in px relative to the size of the map image file.
    // This is needed so that the assets can be drawn at the correct relative size
    // regardless of zoom level and canvas size
    var ART_SIZES = {
        "flagpole_width": 6,
        "flagpole_height": 30,
        "flag_size": 15,

        "city_radius": 6,
        "city_border_width": 1,

        "initial_label_size": 20,  // Font height
    }

    var images = {};
    images.map = new Image();
    images.map.src = "{{ url_for("static", filename="europe.png") }}";

    var cities_str = document.getElementById("cities").innerHTML;
    var airports_str = document.getElementById("airports").innerHTML;
    cities_str = cities_str.replace(/&#34;/g, '"');
    airports_str = airports_str.replace(/&#34;/g, '"');
    var map = new Map(cities_str, airports_str);

    var latest_timestamp = 1.1;

    var canvas = $("#game-canvas")[0];
    canvas.width = $("#left-panel").width();
    canvas.height = canvas.width * images.map.height / images.map.width;

    // Disable image smoothing so that map is not blurry when zoomed in
    var ctx = canvas.getContext("2d");
    ctx.mozImageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.msImageSmoothingEnabled = false;
    ctx.imageSmoothingEnabled = false;

    var LABEL_STYLE = {"colour": "white", "font": "VT323, monospace"};
    var LABEL_SIZE = ART_SIZES.initial_label_size * canvas.width / images.map.width;

    var game;

    images.map.onload = function() {
        game = new Game(map, canvas);

        // Get the status and start the update loop
        getStatus();
        window.setInterval(getStatus, UPDATE_INTERVAL);
    }

    </script>
</body>

</html>
